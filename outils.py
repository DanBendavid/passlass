def n_to_k(n: int, *, seed: int = 42) -> int:
    """
    Donne le rang initial k du nième candidat (n) dans la cohorte Step 3.

    Paramètres
    ----------
    n : int
        Index dans la cohorte Step 3 (0 ≤ n ≤ 849).
    seed : int, optionnel
        Graine utilisée pour générer la même cohorte.

    Renvoie
    -------
    int
        Rang Step 1 (k) correspondant.
    """
    cohort = get_cohort1(seed)  # tableau (850,)
    if not 0 <= n < cohort.size:
        raise IndexError(f"n doit être entre 0 et {cohort.size - 1}, reçu {n}")
    return int(cohort[n])

def simulate_one_cohort(rho: float = 1, seed: int = 26) -> pd.DataFrame:
    cohort_ranks = get_cohort1(seed)

    n = len(cohort_ranks)
    rng = np.random.default_rng(seed)

    # On génère des paires de notes (M1*, M2) corrélées
    z = rng.multivariate_normal([0.0, 0.0], [[1.0, rho], [rho, 1.0]], size=n)

    # Les rangs M1 sont imposés par la cohorte
    rank_m1 = cohort_ranks.copy()

    # Les notes M2 sont simulées aléatoirement
    note_m2 = z[:, 1]
    # On attribue le rang selon la note M2 (1=meilleur)
    rank_m2 = np.argsort(note_m2).argsort() + 1

    df = (
        pd.DataFrame(
            {
                "group": GROUP_LABELS,
                "rank_m1": rank_m1,
                "rank_m2": rank_m2,
                "rank_in_group": _rank_inside_groups(rank_m2),
                "note_m1": _m1_from_ranks(rank_m1),
                "note_m2": _m2_from_ranks(rank_m2),
            }
        )
        .sort_values(["group", "rank_in_group"])
        .reset_index(drop=True)
    )

    return df


def cohort_to_excel(seed: int, path: str | Path = "cohort.xlsx") -> Path:
    """
    Export the cohort ranks generated by get_cohort1 to an Excel file.

    Parameters
    ----------
    seed : int
        Seed for reproducibility.
    path : str or Path, default "cohort.xlsx"
        Output Excel file path.

    Returns
    -------
    Path
        The resolved path to the saved Excel file.
    """
    df = get_cohort1(seed)
    path = Path(path).expanduser().resolve()
    path.parent.mkdir(parents=True, exist_ok=True)
    pd.DataFrame(df, columns=["rank"]).to_excel(path, index=False)
    return path


def df_to_excel(seed: int, path: str | Path = "cohort_et_notes.xlsx") -> Path:

    df = simulate_one_cohort(rho=0.7, seed=26)  # Export Excel
    path = Path(path).expanduser().resolve()
    path.parent.mkdir(parents=True, exist_ok=True)
    df.to_excel(path, index=False)
    return path


def simulate_random_cohort_to_excel(
    rho: float = 0.7, seed: int = None, path: str = "simulation_aleatoire.xlsx"
) -> pd.DataFrame:
    """
    Simule une cohorte aléatoire, une épreuve M2 corrélée, et exporte les résultats en Excel.

    Params
    ------
    rho : float
        Corrélation M1-M2.
    seed : int or None
        Graine pour la reproductibilité. None = totalement aléatoire.
    path : str
        Chemin du fichier Excel à générer.

    Returns
    -------
    df : pd.DataFrame
        Le DataFrame généré (et exporté).
    """
    rng = np.random.default_rng(seed)
    # Tirage d'une nouvelle cohorte
    cohort_ranks = get_cohort1(rng.integers(1e9))
    note_m1 = _m1_from_ranks(cohort_ranks)

    # Attribution des groupes à la cohorte
    group_labels = assign_groups_round_robin(NB_LAS, GROUP_SIZES)

    # Simule M2 corrélée à M1
    z = rng.multivariate_normal(
        [0.0, 0.0], [[1.0, rho], [rho, 1.0]], size=NB_LAS
    )
    note_m2_base = z[:, 1]
    rank_m2 = note_m2_base.argsort()[::-1].argsort() + 1

    # Rang dans le groupe : nouvelle fonction robuste
    rank_in_group = rank_inside_groups(rank_m2, group_labels)

    # Note finale M2 (fonction de rang_in_group et du groupe)
    def _m2_from_ranks_custom(ranks, group_labels):
        intra = ranks - 1  # 0‑based intra ranks
        gsize = GROUP_SIZES[
            np.array([int(str(g).replace("G", "")) - 1 for g in group_labels])
        ]
        return 20.0 * (1.0 - intra / (gsize - 1))

    note_m2 = _m2_from_ranks_custom(rank_in_group, group_labels)

    df = (
        pd.DataFrame(
            {
                "group": group_labels,
                "rank_m1": cohort_ranks,
                "note_m1": note_m1,
                "note_m2_base": note_m2_base,
                "rank_m2": rank_m2,
                "rank_in_group": rank_in_group,
                "note_m2": note_m2,
            }
        )
        .sort_values(["group", "rank_in_group"])
        .reset_index(drop=True)
    )

    df.to_excel(path, index=False)
    return df